---
title: "genomicSimulation (v0.2.5) Vignette"
author: "Kira Villiers"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
      fig_caption: true
      number_sections: true
      toc: true
      #theme: simplex
vignette: >
  %\VignetteIndexEntry{genomicSimulation (v0.2.5) Vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

**Significant changes in v0.2.5**:

- As part of efforts to increase naming consistency between R and C versions of the package, some R functions have changed names. The old function names still work, but may become deprecated at some point in future.

| Old name | New (recommended) name |
|:-----    | :----- |
| see.minimum.GEBV | see.minimal.GEBV |
| select.by.gebv | break.group.by.GEBV |
| make.group.from.label | break.group.by.label.value |
| make.group.from.label.range | break.group.by.label.range |
| make.label | create.new.label |
| load.different.effects | load.more.effects |
| cross.randomly | make.random.crosses |
| cross.randomly.between | make.random.crosses.between |
| cross.combinations | make.targeted.crosses |
| cross.combinations.file | make.crosses.from.file |
| cross.dc.combinations.file | make.double.crosses.from.file |
| cross.all.pairs | make.all.unidirectional.crosses |
| save.local.GEBVs.by.file | save.local.GEBVs.blocks.from.file |
| save.local.GEBVs.by.chr | save.local.GEBVs.blocks.from.chrsplit |
	
See package's NEWS.md file for more detail and other changes.

```{r setup}
library(genomicSimulation)
```

# Introduction
genomicSimulation is a simple, fast scripting simulation tool for creating 'digital twins' of breeding schemes. The package tracks genotypes at an individual level, and performs stochastic simulation of meiosis (including crossing-over but not mutation) to simulate crossing.

All core functionality is written in C. Performing the computation-intensive tasks at C-level allows for quick runtimes. Because it was initially created for simulating plant breeding programs, the package does not automatically track sex.

Contact the package maintainers for any feature requests or improvement requests, or to report any bug or crash. 

Guides on using the package can be found in sections 4 and 5 of this vignette.

[A formal writeup of this tool's design and performance is available on bioRxiv.](https://www.biorxiv.org/content/10.1101/2021.12.12.472291v2)

## Getting to know genomicSimulation

genomicSimulation aims to give you a set of flexible building blocks with which you can design/script a breeding program. genomicSimulation exists as a set of scripting functions at R level (like `load.more.genotypes`, `cross.randomly`, and `see.optimal.haplotype`) and an invisible table containing the simulation's currently-existing genotypes. 

Working with genomicSimulation is about being able to build your simulation structure as you wish. Broadly speaking, simulation functions are split into three categories: creating more genotypes, selecting between genotypes, and reorganising/recategorising genotypes. These categories of actions can be used in any order and interspersed in any way. In fact, the only fixed requirement of a valid genomicSimulation script is that the first command is `load.data()`, which initialises the invisible table and loads the genetic map, which is the one un-changeable detail of a simulation. 

In genomicSimulation, every genotype is a member of a 'group', an abstract category represented by a number. Selection is simulated by pulling selected genotypes into a new group; most crossing actions are performed using one group's members. Groups can be combined, split randomly, or split along specific lines. Groups can be deleted to destroy the genotypes they contain. 

Using these two factors (all genotypes being allocated to reconfigurable groups, and simulation actions being able to be undertaken in any order) genomicSimulation has the flexibility to simulate a huge range of breeding programs. You can imagine repeatedly simulating crosses from a 'breeding pool' group and discarding most offspring but for a selected subset which you merge into your breeding pool for the next generation, or simulating a nucleus breeding system with several funneled breeding pools running simultaneously, each replenished by the best offspring of their own pool and whatever trickles down from higher/more elite pools, or a concurrent population development/improvement program which splits off copies of certain genotypes to repeatedly self into homozygosity and test in the field.

genomicSimulation's data is, unfortunately, stored in an invisible table. In this case, 'invisible' means there is a hidden variable `sim.data$p` of the 'external pointer' type in your R environment when a genomicSimulation simulation is in existence. This pointer is the address of an . Unfortunately, with genomicSimulation (and therefore its constituent tables) being built in C, there is no nice way for R to be able to see them.

Instead, you will have to call genomicSimulation functions to look at your simulation data. As an R user, the functions `see.existing.groups()` and `see.group.data()`, which pull the data into R vectors, will become your friends. 


# Speed
On a consumer-model laptop laptop (Intel(R) Core(TM) i5-7200U CPU @ 2.50GHz, 8GB RAM) running RStudio version 1.2.5019, the process of loading 50 founder lines and 5112 SNPs took on average 0.64 seconds.

A call to `cross.randomly` to generate 100,000 ($10^5$) offspring from those founders took on average 2 seconds to run. Since all crossing functions use the same underlying meiosis simulation and same methodology, this time should be fairly representative of the speed of any crossing function. 

Output (writing to files) adds significant delays. The same command, with save-as-you-go output of GEBVs and pedigrees active, took approximately 20 seconds to run. With save-as-you-go output of GEBVs, pedigrees, and genotypes (genotypes in particular write a lot of characters to files), the function call took approximately 120 seconds. 

Generating the 100,000 offspring, then saving GEBVs, pedigrees, and genotypes to files via separate `save.` functions, took approximately 130 seconds to complete. This is a few seconds longer than the save-as-you-go call that did the same work, possibly because of the time spent moving from R-level execution to C-level and back again.

The C-level functions make no attempt to parallelise execution.

# Package-Specific Details
## Understanding `sim.data`
The package has an internal invisible table where it stores simulated genotypes and other details. The table is a 'struct' object, called `SimData`, in the simulation tool's underlying C library. An external pointer to `SimData` is saved in a package-global R variable called `sim.data$p`. `sim.data$p` is hidden during regular use, and attempting to access the C-level data via the external pointer is not advised. Plenty of R-level functions are offered to modify and view simulation state and stored data.

To reset the simulation/clear it of all data, the function `clear.simdata()` is provided. Currently, functionality to have two concurrent simulation states does not exist.

### Markers
Each `SimData` is given a list of markers and a map for positioning these in the genome on creation (see Indexes: Input File Formats: Linkage maps). These are the only details that cannot be changed after creation without clearing the `SimData`: they serve as the foundation of the invisible table. 

The `SimData` object saves names of markers as-is, as long as the name is under 45 characters long. Behaviour is undefined if any marker name is longer than 45 characters. (The currently-non-modifiable NAME_LENGTH setting (see Indexes: Global Settings Index) is associated with work on fixing this limitation).

Because the `SimData` stores its markers in genome order, any outputs produced will have the markers ordered according to the genetic map loaded at its creation. If an output method provides genotypes as strings of alleles, the string will also be ordered according to this genetic map.

Note that genomicSimulation does not care what potential values/alleles the marker can take. Any 8-bit non-space character will be accepted as an allele. This means SNP markers can be represented with the two alleles 0 and 1, or A and T, etc., according to your preference. On the other end of the spectrum, a marker could also represent an abstracted Mendelian gene with alleles A, a, t, +, and o. 

### Effects
The simulation calculates genetic breeding values for an arbitrary trait using an additive model.

While the simulation cannot run without a genetic map, it will happily run without effect values. There is no need to provide effect values if genetic breeding values are not to be used. If they are to be used, the simulation can load an effect file containing the additive effect of having a given allele at a given marker (see Indexes: Input File Formats: Effect files). The genetic breeding values are then calculated by adding up the effects of each allele in the genotype for which there is an effect loaded (that is, markers and alleles not mentioned in the effect file contribute nothing to the score).

Additional sets of marker effects can be loaded in with `load.different.effects()`. Each set of marker effects will have a numeric identifier (sequential natural numbers starting at 1), which is presented to the user as the return value from the function that loaded that effect file. All breeding value calculations will, by default, use the first loaded set of marker effects. The numeric identifier of a different set of marker effects can be passed to the `eff.set` parameter of these functions to use that marker effect set instead.

### Genotypes
Each genotype/line may or may not be given a name. Generating names for simulated genotypes can be turned on in the common crossing settings (see Indexes: Crossing Function Settings). 

At least one genotype must be loaded in the initialisation command `load.data`. genomicSimulation has no genome-construction or mutation mechanisms: there is no other way to get your simulation population started! At any point in simulation more genotypes can be imported from files using the function `load.more.genotypes` (see Indexes: Input File Formats: Founder genotypes).

When loading genotypes from a file, behaviour is undefined if any genotype has a name longer than 45 characters. (Once again, the currently-non-modifiable NAME_LENGTH setting (see Indexes: Global Settings Index) is implicated in attempts to remove this limitation.)

## Understanding Groups
As far as genomicSimulation is concerned, every genotype always exists as a member of a group. Genotypes loaded from the same file are automatically allocated to the same group. Every crossing function also places the genotypes it produces in a new group. Each group is denoted by a number.

A genotype can only belong to one group, so functions that overwrite allocations (eg `make.group`) effectively pull genotypes out of their old group and put them into the new one. This ensures that genotypes can only be deleted once.

Group numbers are natural numbers starting at 1. Group numbers are not guaranteed to be allocated sequentially, because some crossing functions may create and delete temporary groups to carry out their task, so the final group number could be 'out of order'. 

The group numbers of groups created or modified by a function call will be given in the return value of the function. In your R environment, the groups you are working with will be to all intents and purposes just integers. Note that only genomicSimulation functions can actually make changes to the groups. Modifying the numbers returned by genomicSimulation in the R environment will have no effect, and furthermore genomicSimulation will not, for example, delete a number in the R environment if that group ceases to exist.

## Understanding Custom Labels

Sometimes you might have reason to want to track extra details about your genotypes (a common use case would be the age of the simulated individual), or you might want a categorisation system that persists even when groups are broken apart, dissolved, and/or reformed in efforts to perform particular selection or mating procedure.

A custom label is an attribute or field that is stable until changed by the user. genomicSimulation gives its users the power to create as many labels as desired, to set default values for each label, and to change the value of the label on each simulated individual.

Every genotype in the simulation will hold some value in every label that exists. Specifically, the values of the labels must be integers (whole numbers). Interpretation of the labels (e.g. age in months; year of birth; phenotype), is up to the user to keep track of: genomicSimulation only knows the ID of each label, and the values of that label for every simulated individual.

Like group numbers, label IDs are integers greater than 0. The function `make.label` returns the label ID of the label it just created. This is an exception to the usual rule that functions return the group number of the group that was created, or 0 if they did not create a new group. Label manipulation functions like `change.label.by.amount` do follow the pattern and return 0, since they do not create a new group. 

Also like groups, use `delete.label` to delete a custom label (all simulated individuals will still exist, but they will no longer have any value under the custom label that no longer exists). Merely removing the label ID from the R environment does nothing to remove the label from simulation memory.

## Understanding Identifiers
There are five categories of identifiers that may be observed during use of the simulation.

1. Group numbers/group IDs, which were discussed in the preceding section on groups. They are integers greater than 0 that define a set of genotypes/lines. Any number of lines can share a group number, and a line's group number may be changed over the course of the simulation.
1. Label IDs, which were discussed in the preceding section on labels. Like group numbers, they are integers greater than 0. They define a particular custom label. A label keeps its same identifier for its lifetime.  
1. Effect Set IDs, which were discussed in the preceding section on sets of marker effects for calculating breeding values. Like group numbers and label IDs, they are integers greater than 0. They define a particular set of marker effects. A marker effect set keeps its same identifier for its lifetime in the simulation (though, if you load the same effect file multiple times, there could be multiple identical marker effect sets in the simulation).
1. Genotype Pedigree IDs. These are integers greater than 0 that are unique to a particular genotype for the lifetime of the simulation. IDs are used for tracking pedigree. However, genotypes are not guaranteed to have an ID: genotypes created during crossing with the setting `give.ids` set to FALSE will not be allocated IDs and will have 0 instead. 
1. Indexes. These represent the position/column number in the invisible table at which the genotype is stored. They are therefore unique to the genotype but not continuous over the lifetime of the simulation, because when genotypes/columns are deleted, the column numbers of the remaining genotypes may change. Because, unlike IDs, every genotype is guaranteed to have an index, functions like `make.group` and `cross.combinations` that act on specific genotypes (rather than groups) generally take indexes as inputs. Since indexes can change, however, it is important to not place a `delete.group` call between getting index data and using indexes in one of these function calls.

The return values of nearly every function in the package (excluding the functions that pull data into R, whose names begin with `see.`) are vectors of integers representing one of the first three identifiers, above. If the function is `make.label`, it returns the new label's ID. If the function is `load.different.effects`, it returns the marker effect set from the provided effect file's new effect set ID. Most commonly, if the function created or modified groups, the return value(s) are the group number(s) of the group(s) created or modified. If the function returns 0, then it succeeded but did not change any groups. 

## Understanding Output Methods
There are three sets of functions to get output from the simulation. 

- The first involves calling a function to save data to a file (`save.` family functions). These can be called on any group or on the entire simulation, cover a range of data types, each which has a few possible output formats (see Indexes: Output File Formats).
- The second involves saving the data about a cross at the same time as producing it (`save.` settings in crossing function parameters). This enables more compact data saving, and also allows for simulating more crosses than can be stored in working memory, by also setting the parameter `retain=FALSE`. In save-as-you-go saving, the simulation generates and saves crosses in batches of 1000 (This value could be changed by modifying the CONTIG_WIDTH setting (see Indexes: Global Settings Index)). save-as-you-go is however less flexible than `save.` family functions because only the default printing format is used and only the genotypes produced by that particular crossing call are saved.
- The third is to use the `see.` family of functions to pull data into R. These are the only functions that break the rule of function return values being either group numbers or 0 (see Understanding Groups). The custom selection method interface in R is designed to work with these functions (see Workflow: Writing Custom Selection Methods in R). 

See the indexes of this vignette for information on available functions and output formats. 

# Workflow
A simple workflow for this package could be:

1. Load progenitor lines and SNP data; save the group number of the progenitor lines. (The effect values for calculating breeding values for a desired trait can be loaded here too, if desired). Suggested function: `load.data`
1. Perform crossing from the progenitor group. Keep a hold of the group number of these crosses. Example function: `make.random.crosses`
1. Perform selection on the F1 generation generated above. Example function: `break.group.by.GEBV`
1. Perform more crossing from the F1 generation (using the group number from the above step).
1. Repeat for further generations.
1. Save the final genotypes (and/or effect values and/or pedigrees) to files. Example function: `save.genotypes`
1. (Optional: Estimate the number of crossovers to reach these final genotypes. Suggested function: `plot.crossovers`)
 Open output files for further analysis.

The example below shows a how a typical workflow would save group numbers and call crossing functions.
```{R}
# (Show the tiny example data set)
read.csv("../tests/testthat/helper_genotypes.txt", sep='\t', header=T)
read.csv("../tests/testthat/helper_map.txt", sep='\t', header=T)
read.csv("../tests/testthat/helper_eff.txt", sep='\t')

# Starting to use genomicSimulation: load the small initial data set
init <- load.data("../tests/testthat/helper_genotypes.txt",
                "../tests/testthat/helper_map.txt",
                "../tests/testthat/helper_eff.txt")
g0 <- init$groupNum
# eff1 <- init$effectID, the identifier of the effect file loaded, is the other entry in the list 'init'

# Do random crosses from the progenitor lines. 
f1 <- make.random.crosses(g0, n.crosses=20, give.names=TRUE, name.prefix="F1.")

#(Let's see what crossovers occured. For this few markers we don't get much information.)
save.pedigrees("a.txt", f1, type="P")
find.plot.crossovers("a.txt", "b.txt")

# Find the 25% with the top breeding value/GEBV
f1.selected <- break.group.by.GEBV(f1, percentage=25)

# Delete groups we are not currently using, to free up some memory.
delete.group(f1)

# Make 40 random crosses from those selected 25%
f2 <- make.random.crosses(f1.selected, n.crosses=5)
delete.group(f1.selected)

# Complete 4 rounds of selfing with save-as-you-go genotype saving
f6 <- self.n.times(f2, 4, file.prefix="af6", save.genotype=TRUE)

# Show current state of groups.
see.existing.groups()

# (These are the groups the above command should show)
print(c(g0, f2, f6))

# Show the save-as-you-go output file
read.csv("af6-genotype.txt", sep='\t')


# (cleanup)
file.remove("a.txt")
file.remove("b.txt")
file.remove("af6-genotype.txt")
```

## Tracking Sex of Genotypes

The above example, while not very realistic, was clearly inspired by plant breeding methods: four generations of selfing to produce a homozygous inbred fit for bulking and commercial release is not a usual strategy in animal breeding. Perhaps a key aspect in which animal breeding programs differ from a self-pollinated plant breeding program is that you can't cross just any animal with any other animal. That is referring, in part, to the higher importance of avoiding inbreeding, but mostly to the fact that animals come in male and female varieties.

genomicSimulation does not track sex of genotypes. The group system can however be used to that effect.

```{R}
# Starting to use genomicSimulation: load the small initial data set
init <- load.data("../tests/testthat/helper_genotypes.txt",
                "../tests/testthat/helper_map.txt",
                "../tests/testthat/helper_eff.txt")
cows <- init$groupNum
# Load the small initial data set again, pretending this represents a different set of genotypes
bulls <- load.more.genotypes("../tests/testthat/helper_genotypes.txt") 

# Create some offspring
f1 <- make.random.crosses.between(cows, bulls, n.crosses=5)

# Simulate the sex of offspring
temporary <- break.group.randomly(f1, into.n=2)
calvesF <- temporary[1]; calvesM <- temporary[2]; rm(temporary);

#... and so forth
```

Alternatively, a custom label could be used to track sex:

```{R}
# Starting to use genomicSimulation: load the small initial data set
init <- load.data("../tests/testthat/helper_genotypes.txt",
                "../tests/testthat/helper_map.txt",
                "../tests/testthat/helper_eff.txt")
cows <- init$groupNum
# Load the small initial data set again, pretending this represents a different set of genotypes
bulls <- load.more.genotypes("../tests/testthat/helper_genotypes.txt") 

# Define our interpretation of the custom label
FEMALE <- 1L
MALE <- 2L
# Create the label
sexLabel <- make.label(default=FEMALE)
change.label.to.this(sexLabel, MALE, group=bulls)

# Create some offspring
f1 <- make.random.crosses.between(cows, bulls, n.crosses=5)

# Simulate the sex of offspring
change.label.to.values(sexLabel, values=c(sample(c(FEMALE,MALE), size=5, replace=TRUE)), group=f1)

# Then split up your calves as needed
calvesF <- break.group.by.label.value(sexLabel, FEMALE, group=f1)
calvesM <- f1 #the calves left in F1 must be all the males

#... and so on
```

More sample scripts for simulating common scenarios using genomicSimulation can be found in [this Templates page](https://vllrs.github.io/genomicSimulationC/html/templates.html).


## Writing Custom Selection Methods in R
The only inbuilt selection method in genomicSimulation is `select.by.gebv`. However, custom selection methods can be written in R thanks to the `make.group` function, which takes an arbitrary set of indices and moves them into a new group. Indices of genotypes can be accessed via `see.group.data` with data type parameter `X`, operated on, then passed back to `make.group` to perform selection.

For an example, consider that a user wants to implement a custom selection method wherein they select the top 10 simulated crosses by phenotype. Because genomicSimulation offers no internal method for simulating phenotypes, the user must simulate them in R then use the custom selection method interface to perform their selection.

Suppose the user chooses the following model for their simulated phenotype. The phenotypic values will be made equal to the breeding value plus a draw for environmental variance from a normally distributed distribution with variance $V_e$, where $V_e$ comes from the equation $H^2 = V_g/(V_g + V_e)$. For the user's purposes, $H^2$ is a known broad-sense heritability estimate and $V_g$ is the variation in breeding values in the set of crosses from which they are selecting. Therefore, this approach uses the following steps to simulate phenotypes are: 
1. calculate the magnitude of $V_e$ using the set of breeding values from the crosses on which selection is being performed
2. draw from a normal distribution to get simulated phenotypes

The user creates the following R function to perform their selection:

```{R}
get.top.10.phenotypes <- function(group, heritability) {
  info <- data.frame(Index=see.group.data(group,"X"),
                     GEBV=see.group.data(group,"BV"))
  
  # simulate phenotype = genotype + environmental variation
  # using normally distributed Ve and heritability H^2 = (Ve + Vg)/Vg
  Vg <- var(info$GEBV)
  Ve <- Vg/heritability - Vg
  info$Pheno <- info$GEBV + rnorm(length(info$GEBV), mean=0, sd = sqrt(Ve))
  
  # Select those with the top phenotype
  return( info[order(info$Pheno, decreasing=TRUE),]$Index[1:10] )

}
```

and uses it via the make.group interface:
```{R}
init <- load.data("../tests/testthat/helper_genotypes.txt",
                "../tests/testthat/helper_map.txt",
                "../tests/testthat/helper_eff.txt")
g0 <- init$groupNum

# Simulate crosses
f1 <- make.random.crosses(g0, n.crosses=15, offspring=3)
# Apply custom selection method
f1.selected <- make.group(get.top.10.phenotypes(f1, 0.3))
# (delete the non-selected genotypes)
delete.group(f1)

# ... repeat for further generations
f2 <- make.random.crosses(f1.selected, n.crosses=100)
f2.selected <- make.group(get.top.10.phenotypes(f2, 0.5))

# ...
delete.group(c(f1.selected,f2,f2.selected))
```

The [writeup on bioRxiv](https://www.biorxiv.org/content/10.1101/2021.12.12.472291v2) includes the simulation results of a sample breeding program similar to this concept. 

# Details and Methodology

## Methodology: Calculating Breeding Values
The terms 'breeding value', 'genetic breeding value' and 'GEBV' (Genetic Estimated Breeding Value) are used interchangeably in the package, because the simulation is ignorant of whether real or estimated breeding values were loaded.

The package's internal GEBV calculator uses an additive model of trait effects. The additive effect values loaded from an input file (either via the `load.data` or the `load.different.effects` functions) are stored as a vector for each allele. In calculating breeding values for a genotype, the simulation counts how many copies of each particular allele the genotype has at each SNP, then multiples the vector of counts for a particular allele by the effects for that allele. The final result is the sum of these products across all alleles for which it has a stored effect vector.

![Diagram of the breeding value calculation process.](bvcalculation.png){width=100%}


## Methodology: Simulating Meiosis
To create a cross, the simulation generates gametes independently for the two parents. No distinction is made between male and female parent. Simulation of meiosis is also independent between crosses - the second gamete produced by simulation of meiosis is discarded, not saved for later.

For each chromosome number, the number of crossovers to occur in the simulated meiosis are drawn from a Poisson distribution with parameter = [length of the chromosome in Morgans], where length of the chromosome is the distance between the first and last SNP tracked by the linkage map that are on that chromosome. The positions of those crossovers along the chromosome are then drawn from a uniform distribution, which is why the use of a linkage map (so that distances correspond to likelihood of crossover) is recommended over use of a physical map. Finally, a random logical value (0 or 1) is drawn to choose which of the parent's chromosomes to start with (which of the two gametes produced to use). 

Note that this means that allele order in parents matters, and the simulate genotypes that are produced are phased. <!--Encoded data loaders like `load_transposed_encoded_genes_to_simdata` randomise the order of alleles when the line is heterozygous at a SNP on loading.-->

The R package uses the R random generators, so will follow the R seed.

<!--![Random draws for each chromosome](meiosisdists.png){width=100%}
![Using those random values to generate a gamete](meiosis.png){width=100%}-->

![Diagram of meiosis simulation process.](meiosis.png){width=100%}


## Methodology: Counting Recombinations
Extra functionality is available for estimating where crossovers occured in producing certain genotypes. This is offered by the `find.crossovers` and `find.plot.crossovers` functions. The difference between the two is that after crossovers points are found, as well as saving the results matrix to a file `find.plot.crossovers` produces an R plot, as shown below. It assumes the child is mostly homozygous.

![An example plot produced by the crossover finder function with certainty=FALSE. The lines plotted were produced by crossing the two parents then selfing for 6 generations. This produces a large number of crossover events.](crossovers.png){width=100%}

To identify crossovers, the code starts at the beginning of each chromosome for the current child line, and reads through to find SNPs where the parents differ. Here, the provenance of the child's genotype can be determined.

The functions have two parameters that affect the way the crossover counting works: `window.size` and `certainty`.

If the `certainty` setting is `True`, then SNPs where the provenance of an allele cannot be determined are marked with a 0, representing unknown parentage. If the `certainty` setting is `False`, when the provenance of an allele is unknown, the parentage at that SNP is set to the same parent as the most recent SNP with known parentage.

The `window.size` parameter should be an odd positive integer. The window size is the number of SNPs that are observed at a time. Only if the alleles of the child at all SNPs in the window represent a sequence that could have come from one parent, and that same sequence cannot have come from the other, is the parentage at that SNP considered known.

In developing this process it was considered that parent and child lines would be mostly homozygous. 

This functionality is very much untested and incomplete.

# Indexes
## Global Settings Index

- NAME_LENGTH (default 45).
- CONTIG_WIDTH (default 1000).

Generally, these default parameter settings should be satisfactory. If you do need to change them, add a line of the format `#define CONTIG_WIDTH 2048`, with your desired variable to modify and desired value to change it to, to the first line of `src/genomicSimulation-init.c`.

## Function Index
*Use the R documentation (eg. type `?load.data` in the RStudio console) to get descriptions of these functions.*

*There are square brackets around outputs to represent that they are placeholder names and can be replaced by any variable name of your choice.*

*The words in the brackets of each function convey the names of the parameters and their default values, if any. The function `load.data(allele.file, map.file, effect.file = NULL)` could be called as:*

- *`load.data(allele.file=[filename1], map.file=[filename2], effect.file=NULL)`, or*
- *`load.data(allele.file=[filename1], map.file=[filename2], effect.file=[filename3])`, or*
- *`load.data([filename1], [filename2])` (note that this call excludes parameter names, so the order of the filenames matters, and no value is provided for the third parameter, so the default value NULL will be used).*

*Many crossing functions are marked as having `[[settings]]` as a parameter. [[settings]] represents a shared set of optional parameters, described in * ***Section 6.3: Crossing Function Settings.***


Loading data:

- `[group] <- load.data(allele.file, map.file, effect.file = NULL)`
- If the effect file in `load.data` is not NULL, the return type is instead `list(groupNum=[group], effectID=[effect set])`
- `[group] <- load.more.genotypes(allele.file)`
- `[effect set] <- load.more.effects(effect.file)`
- `delete.effect.set(effect.sets)`

Simulating crossing:

- `[group] <- make.random.crosses(group,n.crosses,[[settings]])`
- `[group] <- make.random.crosses.between(group1,group2,cap1,cap2,n.crosses,[[settings]])`
- `[group] <- make.targeted.crosses(first.parents,second.parents,[[settings]])`
- `[group] <- make.crosses.from.file(cross.file,[[settings]])`
- `[group] <- make.double.crosses.from.file(cross.file,[[settings]])`
- `[group] <- make.all.unidirectional.crosses(group,[[settings]])`
- `[group] <- self.n.times(group,n,[[settings]])`
- `[group] <- make.clones(group,inherit.names,[[settings]])`
- `[group] <- make.doubled.haploids(group,[[settings]])`

Manipulating custom labels:

- `[label] <- create.new.label(default)`
- `delete.label(labels)`
- `change.label.default(label, default)`
- `change.label.to.values(label, values, in group/no group, startIndex)`
- `change.label.to.this(label, value, in group(s)/no group)`
- `change.label.by.amount(label, amount, in group(s)/no group)`

Performing selection:

- `[selected.group] <- break.group.by.GEBV(from.group, low.score.best = FALSE, percentage OR number, eff.set=1L)`
- For more customised selection, use the process
  - `info <- data.frame("i" = see.group.data(from.group,"X"), "Data"=see.group.data(from.group,...))`
  - `selected.info <- `[some R manipulation on `info` that discards rows not selected under the custom selection]
  - `[selected.group] <- make.group(selected.info$i)`

Modify groupings:

- `delete.group(groups)`
- `[group] <- combine.groups(groups)`
- `[group] <- make.group(indexes)`
- `[group] <- break.group.by.label.value(label, value, in group(s)/no group)`
- `[group] <- break.group.by.label.range(label, rangeLowEnd, rangeHighEnd, in group(s)/no group)`
- `[vector of groups] <- break.group.into.individuals(group)`
- `[vector of groups] <- break.group.into.families(group)`
- `[vector of groups] <- break.group.into.halfsib.families(group)`
- `[vector of groups] <- break.group.evenly(group, into.n = 2)`
  - `[vector of groups] <- break.group.into.buckets(group, [vector of buckets])`
- `[vector of groups] <- break.group.randomly(group, into.n = 2)`
  - `[vector of groups] <- break.group.with.probabilities(group, [vector of probabilities])`

Save data (saves results to files):

- `save.genotypes(filename, group = NULL, type = "R")`
- `save.allele.counts(filename, group = NULL, allele)`
- `save.pedigrees(filename, group = NULL, type = "R")`
- `save.GEBVs(filename, group = NULL, eff.set=1L)`
- `save.local.GEBVs.by.chr(filename, n.blocks.per.chr, group = NULL, eff.set=1L)`
- `save.local.GEBVs.by.file(filename, block.file, group = NULL, eff.set=1L)`

View data (pulls data into R dataframes):

- `[dataframe containing current existing groups and their sizes] <- see.existing.groups()`
- `[vector containing the chosen data] <- see.group.data(group, data.type, eff.set=1L)`
- `[string containing best allele at each SNP] <- see.optimal.haplotype(eff.set=1L)`
- `[string containing best allele that exists in the group at each SNP] <- see.optimal.possible.haplotype(eff.set=1L)`
- `[float: the maximum possible GEBV] <- see.optimal.GEBV(eff.set=1L)`
- `[float: the maximum possible GEBV from the pool of alleles that exist in the group] <- see.optimal.possible.GEBV(eff.set=1L)`
- `[float: the minimum possible GEBV] <- see.minimal.GEBV(eff.set=1L)`

Identify recombination events:

- `find.crossovers(parentage.file, out.file, window.size = 1, certainty = TRUE)`
- `find.plot.crossovers(parentage.file, out.file, window.size = 1, certainty = TRUE)`

Data Storage:

- `clear.simdata()`

## Crossing Function Settings
All crossing functions take in a common set of settings. These are briefly described below.

- `offspring` : A setting representing the number of times to do each cross.
- `retain` : A boolean, repesenting whether to save the generated genotypes to memory or discard them. You may wish to discard them but save to file if you are generating too many crosses to save into memory.
- `give.names` : A boolean representing whether or not to produce names for the new genotypes generated. The names produced would have format [name.prefix][id]
- `name.prefix` : A string. If give.names is TRUE, the id is concatenated to this to produce the name of each new genotype.
- `track.pedigree` :A boolean representing whether or not to save the ids of the parents of each new genotype to the new genotype's pedigree. If this is false, the new genotype's pedigree is unknown.
- `give.ids` : A boolean representing whether or not to allocate each new genotype an id. If this is FALSE, the new genotype is 'invisible' to pedigree trackers and even if the pedigree of its offspring is supposedly tracked, the pedigree trackers will not be able to identify the progenitors of its offspring. Furthermore, if it is false and names are generated using give.names, all names generated in the same group will be the same. Probably you'd only have this FALSE if you were discarding the results or worried about id overflow.
- `file.prefix` : A string representing the prefix of files produced if save.pedigree=TRUE, save.gebv=TRUE, or save.genotype=TRUE.
- `save.pedigree` : A boolean. If TRUE, saves the pedigree in recursive format of each generated genotype to the text file with filename "[file.prefix]-pedigree".
- `save.gebv` : An integer. If 0, does not save GEBVs. If greater than 0, saves the GEBVs of each generated genotype to the tab-separated text file with filename "[file.prefix]-eff". The GEBVs will be calculated using the marker effect set whose identifier was given to this parameter.
- `save.genotype` : A boolean. If TRUE, saves the SNP/line matrix in regular format (generated genotypes as rows, SNPs as columns) to the tab-separated text file with filename "[file.prefix]-genome".


## Input File Formats
### Founder genotypes and SNPs
The basic file format expected to the `allele.file` parameter of `load.data` is:
```
name	G01	G02	G03	G04	G05	G06
m1	TT	TT	TT	TA	TT	AT
m3	TT	TT	TA	TA	TT	TT
m2	AA	AA	AA	AA	TT	AA
```
where G01, G02, ..., are the parent lines and m1, m2 and m3 are the SNPs. Cells may be space-separated or tab-separated. The value in the first cell ("name" in this example) is ignored.

To load more genotypes after original creation of the `SimData`, use the function `group <- load.more.genotypes(allele.file)`


### Linkage maps

The function's parameter `map.file` requires a file format like the following:
```
marker chr pos
m3 3 15
m2 1 8.3
m1 1 5.2
```
The first line's values are not checked. After that, it requires that all rows have three tab-separated values. The first should be the marker name, the second an integer representing the chromosome number, and the third a decimal representing the position of the SNP along the chromosome in centiMorgans (cM). 

This function loads only markers that already appear in the `SimData`'s SNP list, which is created from the SNPs in the genotype matrix file (`allele.file`). It will print out how many markers it successfully loaded.


### Effect files
Loading an effect file is optional for running the simulation. Its format should be:
```
m1 A -0.8
m2 A -0.1
m3 A 0.1
m1 T 0.9
m3 T -0.1
m2 T -0.5
```

The first column should be a SNP marker name, the second should be the allele this effect value corresponds to (as a single character), and then a decimal representing the effect value of that allele for that SNP.

A particular SNP/allele combination not being included in the file is equivalent to that combination having an effect value of 0. If a particular SNP/allele combination is included multiple times in a file, only the last occurence is saved.

### Combination crossing functions
Two crossing functions (`make.crosses.from.file` and `make.double.crosses.from.file`) take instructions from files.

- `make.crosses.from.file` : Take a file containing tab-separated pairs of line names and perform those crosses. An example file looks like:
```
G01	G02
G01	G03
G05	G06
G01	G04
```
- `make.double.crosses.from.file` : Supposes that only the names of the precursor lines are known but specific crosses between F1 individuals are wanted. Assumes that those F1 individuals have been produced with id allocation/pedigree tracking turned on. The function therefore reads in a tab-separated file that looks like the below to perform the cross between the offspring of G01 and G02, and the offspring of G03 and G05, and so forth.
```
G01	G02	G03	G05
G01	G03	G05	G06
G05	G06	G01	G04
```


## Output File Formats
### Saving genotypes
Use the function `save.genotypes` or the `save.genotype = TRUE` setting of crossing functions to save the alleles of generated genotypes across the list of SNPs.

It will save genotypes in the following format:
```
	m1	m2	m3
F107	TT	AA	TT
F108	TT	AA	TT
F109	TA	AA	TT
```

Note that this is the transpose of the usual expected input file format. Due to the linked list method used to store genotypes, it will be slower/take more passes over the data to print the transposed equivalent. However, this alternate format (shown below) is available via `save.genotypes` with `type = "T"`.
```
   F107   F108   F109
m1 TT     TT     TA
m2 AA     AA     AA
m3 TT     TT     TT
```

If the members of a specific group are saved, rather than every genotype in the simulation, the output format will include the group number in the corner cell of the table. For example, if group 5 had members F107 and F108:
```
5	m1	m2	m3
F107	TT	AA	TT
F108	TT	AA	TT
```


### Saving pedigrees
Pedigrees can be saved in one of two ways:

- `save.pedigrees`, with `type = "P"`, which saves in the following format, even if grandparents are known:
```
F2010   F107   F107
F2011   F108   F109
```
This is a tab-separated text file. The first column is the child name, and the next two columns are the names of its immediate parents (or single parent duplicated if it was produced by selfing or doubling haploids). If names are not available, IDs are used instead. If parents are unknown, the columns will be blank. 

- `save.pedigrees`, with `type = "R"`, or crossing with setting `save.pedigree = TRUE`, which save in the following format:
```
10	F2010=(F107(G01,G02))
11	F2011=(F108(G01,G03),F109(G02,G03))
```
The function is recursive and will continue to track back to find parents until it reaches a genotype with unknown parentage. If, before it reaches a genotype with unknown parentage, it finds one with a parent that does not exist anymore (that has been deleted), it treats that genotype as having unknown parentage and also prints a warning to the user warning that they may have prematurely deleted some genotypes. Users who did intend to perform that deletion and wish to avoid this warning should turn ID allocation off when generating those to-be-deleted genotypes.

Note that in the example above, F2010 is produced by selfing or doubling a haploid of F107, while F2011 is a cross.

### Saving breeding values
Saving GEBVs, either via the `save.GEBVs` function or the `save.gebv = TRUE` setting of crossing functions, produces an output with the following format:
```
1	G01	1.400000
2	G02	1.400000
3	G03	1.600000
```
This is a tab-separated text file. The first column is the ID, then the name of each line, then the GEBV of that line.

### Saving block effect values/local GEBVs
The effect values for each parental half of a genotype's alleles and summed up for markers in a particular block (defined in the `block.file` parameter) can be saved to a file via the `save.local.GEBVs` function.

A block file with format the following format should be the second parameter:
```
Chrom	Pos	Name	Class	Markers
1	2.3	b000000	b	m1;m2;m3;
2 1.5 b000001 b m4;
...
```

The chromosome number, position and class columns are ignored. Any number of markers can be semicolon-separated in the last column. 

The output file has format:
```
    G1  G2  G3  G4 ...
b000000_1   0.25    0.25    -0.45   -0.45 ...
b000000_2   0.25    0.20    0.05    0.20 ...
b000001_1 ...
b000001_2 ...
```
This is a tab-separated text file.

### Save a summary of the `SimData`
The function `save.genome.model` is deprecated. A replacement will be developed.

### Recombination counters
The matrix saved to a file will have a format like the following:
```
	m1	m2	m3
F07	0	1	0
F08	0	2	0
F09	0	2	0
F10	0	1	0
```
A 0 refers to an unknown parentage. Non-zero values are the ID of the parent from which the allele was inherited. 


## R Output Formats

### `see.existing.groups`
This function returns a dataframe with two columns:

- `Group`, containing the group numbers of all existing groups
- `GroupSize`, containing the number of genotypes currently allocated to that group number.

### `see.group.data`
This function returns a vector containing the values of the chosen data type for each group member. The parameter `data.type` is case-insensitive and matched to the beginning of the string, so `data.type="N"` and `data.type="names"` both will return data of type 'N'.

Available data types: Description (`data.type` parameter value)

- Names (N)
- IDs (D)
- Indexes (X)
- Genotypes (G)
- GEBVs/breeding values (B)
- Name of the first parent, or the first parent's ID if it has no name (P1)
- Name of the second parent, or the second parent's ID if it has no name (P2)
- Full/recursive known pedigree, as a string (PED)


